from machine import Pin, I2C, Timerimport networkimport timeimport machinerequests = 0 #urequests - wysyłania zapytan na adres www, GET, POSTi2c = 0 #obsluga po i2c - RTCi2c2eeprom = 0 #  tak jak wyzej ale do EEPROMAi2c2sensor = 0lan = 0 #modul obslugi wifi, komunikacja z roteremsensorTimer = 0 #timer singleshot, czyli jednorazowego odczekaniamainTimer = 0 #timer 10secondsblink = 0 #flaga ilosc zmian na diodzie czyli migniec x2milikwh = 0 #ilosc migniec - aktualnastartTime = bytearray(7) #zbufforowany czas poprzednieepromTiming = 0 #zmienna globalna do zapisu eeprom co godzinę a nie 10seepromSave = 0#utilitydef resetDevice():    machine.reset()def readRTC(rtc):    time = rtc.readfrom_mem(0x51,2,7)    return timedef bcdToDecimal(bcd):    dec = ((bcd&0x70)>>4)*10 + (bcd&0x0F)    return decdef hoursBcdToDecimal(bcd):    hours = ((bcd&0x20)>>5)*20 + ((bcd&0x10)>>4)*10 + (bcd&0x0F)    return hoursdef yearBcdToDecimal(bcd):    dec = ((bcd&0xF0)>>4)*10 + (bcd&0x0F)    return dec    def bcdToDecimalMin(bcd):    dec = ((bcd&0x30)>>4)*10 + (bcd&0x0F)    return dec    def readDecimalRTC(rtc):    buf = bytearray(7)    try:        time = readRTC(rtc)        buf[0] = bcdToDecimal(time[0])        buf[1] = bcdToDecimal(time[1])        buf[2] = bcdToDecimalMin(time[2])        buf[3] = bcdToDecimal(time[4])        buf[4] = bcdToDecimalMin(time[3])        buf[5] = ((time[5]&0x10)>>4)*10 + (time[5]&0x0F)        buf[6] = yearBcdToDecimal(time[6])    except:        print('EXCEPTION: RTC clock unplugged.')    return buf#setRTC(45,5,16,7,6,19,5)def setRTC(seconds,minutes,hours,date,month,year,day=0):    buf = bytearray(7)    buf[0] = (((seconds//10)<<4)&0x70) | ((seconds%10)&0x0F)    buf[1] = (((minutes//10)<<4)&0x70) | ((minutes%10)&0x0F)    buf[2] = (((hours//10)<<4)&0x30) | ((hours%10)&0x0F)    buf[3] = (((date//10)<<4)&0x30) | ((date%10)&0x0F)    buf[4] = (day&0x07)    buf[5] = (((month//10)<<4)&0x70) | ((month%10)&0x0F)    buf[6] = (((year//10)<<4)&0xF0) | ((year%10)&0x0F)    i2c.writeto_mem(0x51,2,buf)    time = readDecimalRTC(i2c)    print('Date set to(YYYY-M-D HH-MM-SS): 20',time[6],'-',time[5],'-',time[4],'' + \          ' ',time[2],':',time[1],':',time[0])#programdef timeToString(time):     minutes = str(time[1])    if time[1] < 10:        minutes = '0' + minutes    seconds = str(time[0])    if time[0] < 10:        seconds = '0' + seconds    hrs = str(time[2])    if time[2] < 10:        hrs = '0' + hrs    return hrs + ':' + minutes + ':' + seconds + ' ' + str(time[4]) + '-' + str(time[5]) + '-20' + str(time[6])def sensorTimerHandle(timer):    global blink    global milikwh        curr = bytearray(2)    i2c2sensor.readfrom_mem_into(0x23,0,curr,addrsize=8)    sensored = int.from_bytes(curr,'little')    if sensored > 9000:        blink = blink + 1    elif sensored < 7000:        blink = 0        #print(sensored)    i2c2sensor.writeto(0x23,b'\x23')        if blink == 1:        milikwh = milikwh + 1        #print('BLINK')def sendDataToServer(datarg):    url = "http://projektsmiw.ekoprzystanek.pl/request.php"    global requests      #try:    response = requests.post(url,data=datarg,headers={'content-type': "application/x-www-form-urlencoded",'cache-control': "no-cache"})    return response.text    #except:    #    print('EXCEPTION: post request error.')    #return ""def lanConnection(name, password):    global lan    lan = network.WLAN(network.STA_IF); lan.active(True)    #lan.ifconfig(('192.168.0.189', '255.255.255.0', '192.168.0.1', '192.168.222.1')) #to comment if needed    lan.connect(name,password)    while not lan.isconnected():        time.sleep_ms(50)    time.sleep_ms(500)    time.sleep_ms(500)    global requests    requests = __import__("urequests")    #response = sendDataToServer('argument1=dana1&argument2=dana2')    #print(response)def mainTimerHandle(timer):    global milikwh    global i2c    global startTime    global eepromTiming    global eepromSave    currentTime = readDecimalRTC(i2c)    milikwhString = str(float(milikwh))    if milikwh < 1:        milikwhString = '0.0'    sendDataToServer('start=' + timeToString(startTime) + \                     '&time=' + timeToString(currentTime) + '&milikwh=' + milikwhString)    eepromSave = eepromSave + milikwh    toSave = startTime + currentTime + bytes([milikwh])    print(formatDataToReadable(toSave))    if eepromTiming > 358:        #if eepromTiming > 6:        eepromTiming = 0        try:            writeToExternalEeprom(startTime + currentTime + bytes([eepromSave]))            print('Current hour data saved to eeprom')        except:            print("Can't communicate external eeprom")    else:        eepromTiming = eepromTiming + 1    startTime = currentTime    milikwh = 0def readFromExternalEeprom(size,index = 2):    global i2c    currentInput = checkExternalEepromLastIndex(size)    if index != 2:        currentInput = index    buffor = bytearray(size)    i2c.readfrom_mem_into(0x50,currentInput,buffor,addrsize=16)    return buffordef formatDataToReadable(data): #size shall be 15    return timeToString(data[:7]) + '*' + timeToString(data[7:14]) + '$' + str(float(data[14]))def checkExternalEepromLastIndex(size = 0):    global i2c    curr = bytearray(2)    i2c.readfrom_mem_into(0x50,0,curr,addrsize=16)    return int.from_bytes(curr,'little') - sizedef writeToExternalEeprom(buffor):    global i2c    currentInput = checkExternalEepromLastIndex()    i2c.writeto_mem(0x50,currentInput,buffor,addrsize=16)    if currentInput > 0x7FF0: #from beggining if its no place        currentInput = 2    else:        currentInput = currentInput + len(buffor)    currByteArray = bytearray([currentInput])    #if len(currByteArray) == 1:    #   currByteArray = bytearray([currentInput,0x0])    time.sleep_ms(500)    i2c.writeto_mem(0x50,0,currByteArray,addrsize=16)def main():    global i2c    i2c = I2C(scl=Pin(2),sda=Pin(0),freq=50000)        global i2c2sensor    i2c2sensor = I2C(scl=Pin(32),sda=Pin(25),freq=50000)    try:        i2c2sensor.writeto(0x23,b'\x23')    except:        print('EXCEPTION: BH1750 sensor unplugged.')    try:        time = readDecimalRTC(i2c)        print('Current time: 20',time[6],'-',time[5],'-',time[4],'' + \             ' ',time[2],':',time[1],':',time[0])    except:        print('EXCEPTION: RTC clock unplugged.')            try:        lanConnection("HUAWEI Mate 10 lite","12345678")    except:        print('EXCEPTION: Internet connection issue')            global mainTimer    mainTimer = Timer(1)    mainTimer.init(period=10000, mode=Timer.PERIODIC, callback=mainTimerHandle)        global sensorTimer    sensorTimer = Timer(0)    sensorTimer.init(period=200, mode=Timer.PERIODIC, callback=sensorTimerHandle)        global startTime    startTime = readDecimalRTC(i2c)    print("Main function end.")if __name__ == '__main__':    print("Main function start.")    main()